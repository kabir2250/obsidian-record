정수 : byte, short, int, long
논리 : boolean
문자 : char
실수 : float, dauble

char
	2byte \[ ] \[ ]

short
	2byte \[s] \[ ]
	

같은 2byte여도 달라
float
	1\[E]xponent 지수
	  \[M]antissa 가수
	  ex) 312.123=3.12123\*10^2
		  부호 비트 : \[1] / 지수 : \[E8] / 소수점. :  \[M23]
		  소수를 나타내는 건 M(가수) 부분

8byte double
	8byte \[1] \[E11] \[M52]

==따라서 double이 정밀도가 더 높아==
float랑 int는 또 달라

예시 : 9.1234567 라는 실수가 있다고 가정하자.
9는 이진수로 1001인데, 1234567은 이진수로 무한이야
(000111111001101011011011.....(무한실수))
52개 이후부턴 잘릴거야 그럼 오차가 생기겠지
+-M * 10^E
이 형태여야 하니까 1다음엔 무조건 .이 오도록 할거야
==이걸 정규화라고 해==
1001.(000111111001101011011011.....(무한실수))
= 1.001(000111111001101011011011.....(무한실수)) * 2^3
가 되는거지
[[문자 타입]]
[[Java 자료형과 타입]]
[[Data type]]
[[Type casting]]
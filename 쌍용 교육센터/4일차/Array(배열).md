같은 type, 메모리 상에 연속적으로
Index 활용할거야

**선언 방법**
 type \[] 이름 = new type \[size(크기)]
	 예시) int \[] kors = new int[3];
field name 앞은 무조건 type이잖아 그러니까 int\[]가 type인거야!

---

Array는 일단 reference type이잖아. 왜?
int \[] kors;라고 하면 Array declare 맞지.  

근데 kors가 그냥 field라고 해도 되는데, reference field(참조 변수)라고 하면 더 구체적이잖아.  
그리고 그 중에서도 Array name(배열명)이라고 하면 가장 구체적이지.  
근데 array도 local field(지역 변수)일 수 있잖아.  

만약 예시대로라면 stack memory에 주소를 기억할 공간이 만들어지고, 이 공간의 이름이 kors가 되겠지.
근데 이러면 int를 저장하는 곳이 없잖아. 걍 주소만 할당된 것 뿐

heap memory에서 배열이
\[4byte] \[4byte] \[4byte] 이렇게 할당 됐다고 치면 다음 꺼 찾아갈 수 있지
0x100이 시작주소라 치면 두 번째 주소는 0x104, 세 번째 주소는 0x108이겠지

그리고 이렇게 heap memory에 잡혀있는 것의 시작주소가
stack memory에 담기게 돼
\[0x100]

그래서 실제로는 heap에 저장되는거지 stack에 저장되는 게 아니야
\[4byte] \[4byte] \[4byte]
(0번째)  (1번째)   (2번째) ->index(첨자값)

lowerBound(index 최솟값)는 0이 되고, upperBound(index 최댓값)는 array.length -1이 되는거야

**Question) 왜 0번부터 시작이야?**
![[Pasted image 20240704113306.png]]

이걸 보면 알 수 있지. 시작주소를 관리할 때 용이해서!


### 3.1 인덱스로 구간을 표현할 때 [a,b) 방식이 가장 좋다

```null
A) 	2 ≤ i < 13
B) 	1 < i ≤ 12
C) 	2 ≤ i ≤ 12
D) 	1 < i < 13
```

위의 인덱스 넘버링 중 좋은 방법은 A)와 B) 입니다. 그 이유는 다음 두 가지입니다.

1. 시작 수와 마지막 수의 차가 집합의 크기와 같다
2. 두 집합을 붙일 때, 마지막 수와 시작 수가 같아 깔끔하다

A)와 B) 중에는 A)가 더 좋습니다. 그 이유는 다음 두 가지입니다.

1. **(a, b] 컨벤션의 경우 가장 작은 수를 포함하려면 그 수보다 작은 수를 집어넣어야 해서 깔끔하지 않다.** ex) 양수를 표현할 경우, 양수보다 작은 값인 0을 집어넣은 `0≤x` 라는 수식으로 표현해야 함
2. **(a, b] 컨벤션의 경우 가장 작은 수를 포함하려면 공집합을 표현하기 위해서 마지막 수에 가장 작은 수보다도 작은 수를 넣어야 해서 깔끔하지 않다.**

다익스트라는 Xeron PARC에서 Mesa라는 프로그래밍 언어를 만든 경험을 이야기하며 이 주장을 뒷받침합니다. 이 언어에는 앞의 A~D와 같은 컨벤션을 지원하는 특별한 문법이 있었는데, 결국 [a, b) 를 제외한 모든 컨벤션은 오류를 유발하는 원인이 되어 결국 사장되었다는 겁니다.

  

### 3.2 [a, b) 컨벤션을 쓸 때에는 0부터 시작해야 마지막 수가 N이 되어서 깔끔하다.

다익스트라는 만약 인덱싱이 1부터 시작하면, 범위가 1 ≤ i < N+1 이 되고, 0부터 시작하면 0 ≤ i < N 으로 마지막 수가 깔끔하게 떨어지고, 마지막 수가 집합의 크기랑 같아져서 더 좋다고합니다.

추가로, 그는 이 이런 이유로 0이야말로 가장 '자연스러운 수'이며, 따라서 자연수로 취급해야 한다고 주장합니다.

또, 그는 포트란, 알골, 파스칼 같은 언어는 이러한 디테일을 놓치고 있다고 디스했는데, 이 컨벤션을 지키는 C는 장수 언어로 지금까지 군림하고 있고, 그가 비판한 언어는 전부 사장된 것을 보면 어느 정도 예견에 성공했다고 할 수 있겠습니다.

출처 : [다익스트라 의견 관련 블로그](https://velog.io/@toezilla/1D1Q-002.-%EB%B0%B0%EC%97%B4%EC%9D%98-index%EB%8A%94-%EC%99%9C-0%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%A0%EA%B9%8C)


Heap에 관해서는 [[New operator]] 참고
